# Java内存区域
## 1、概述
* 由于JAVA的内存管理机制，导致不需要像C/C++一样手动申请和释放内存。大大降低了内存泄漏和内存溢出的风险，但是如果一旦出现问题，如果不了解虚拟机是怎么工作的，将很难定位问题。
## 2、运行时数据区域
 ![运行时数据区域](https://user-gold-cdn.xitu.io/2018/4/27/16306a34cd8a4354?w=513&h=404&f=png&s=132068)
* 运行时区域主要包括 堆区、方法区（非堆）、虚拟机栈、本地方法栈、程序计数器五个部分：
* 其中线程私有的包括程序计数器、虚拟机栈、本地方法栈，各线程共享的包括堆Heap和非堆（方法区）
    
    * 1、程序计数器：（1）字节码运行到哪一行的计数记录，字节码解释器通过该行号来控制代码执行。（2）多线程运行条件下，通过该行号来定位被唤醒的线程应该从哪里开始执行。 所以每一个线程都必须拥有一个程序计数器。
    * 2、Java虚拟机栈，即线程栈，保存着本地变量以及对象引用。虚拟机栈随着线程开启而启动，随着线程终止而销毁。虚拟机栈会引发StackOverflowError(栈的深度超过了限制的深度，很有可能是方法递归调用的原因)和OutOfMemoryError（栈内存超过JVM规定内存）
    * 3、本地方法栈，虚拟机栈是虚拟机调用JAVA方法（字节码）服务，而本地方法是为执行native方法服务。HotSpot虚拟机将虚拟机栈和本地方法栈合二为一了。
    * 4、堆Heap，这是整个内存区域最大的部分，存放着所有的对象和**数组**，也是GC回收垃圾的主要区域。GC主要分为新生代和老年代，新生代分为Eden区和两个Survivor区。JDK1.8之前还有永久代，之后移除永久代，用元空间取代。
    * 5、方法区（非堆），各线程共享的内存区域，保存类的元信息（常量、静态变量、**JIT编译器编译后的代码**）。
    * 6、运行时常量池，
        ![运行时常量池](https://camo.githubusercontent.com/17620721a9f326a235aeec8956949cec03f3f125/687474703a2f2f6d792d626c6f672d746f2d7573652e6f73732d636e2d6265696a696e672e616c6979756e63732e636f6d2f31382d392d31342f32363033383433332e6a7067)
    * 7、直接内存。不是虚拟机定义的内存，是本机堆外内存。
## 3、HotSpot虚拟机对象
### 对象加载过程

* 检查类是否加载→分配内存→初始化零值→设置对象头→调用init方法
    
    * 检查类是否加载，new 后面的类符号引用是否已经被虚拟机加载，没有加载则执行类的加载过程。
    * 分配内存，内存大小在类加载的时候就已经确定了。根据gc回收堆内存的方式，堆分为规整与不规整。在规整的堆中分配内存用的是指针碰撞法：内存中有个指针将堆分成使用和未使用区，每分配一个对象指针就移动对象大小的距离。在非规整堆中对象是随机分配的，虚拟机维护一个空闲列表，从空闲列表分配内存给对象。

        * 注意分配内存区域时会有线程安全问题，多个线程同时给对象分配内存，可能分配到同一块地址。有两种方式保证线程安全：1、CAS+失败重试，CAS是乐观锁的一种实现方式，先给对象分配地址，再检查是否冲突，冲突之后就重试。2、TLAB 虚拟机为每个线程分配一块单独的区域，在该区域为对象分配内存。如果内存不足则采用CAS方式分配
    * 初始化零值，一些基本类型的数据设为0？
    * 设置对象头，对象头包括对象的哈希码、GC分代年龄、方法区类的元信息引用、锁标识等等。
    * 执行init方法，在虚拟机眼里该对象已经创建了，但是对于java程序来说创建才刚刚开始，执行init方法（构造函数、父类构造函数、类初始化器。。。。。）
### 一个对象内部的内存布局
* java对象内部由三部分组成，1.对象头2.实例字段3.对齐填充（对象占的内存必须是8字节的整数倍，没达到时进行对齐填充）
### 对象访问定位
* 直接指针，虚拟机栈上直接存储对象的引用地址，对象自身存储类引用地址。
* 句柄，虚拟机栈指向堆中的一个句柄池，池中存到堆中对象地址的引用和方法区类对象地址的引用。
### String
* 
```java
    String a = "abc";//驻常量池
    String a2 = "abcd"
    String b = new String("efg");//堆上对象，此动作会产生两个对象，efg也会驻常量池
    String c = b.intern();//返回b字符串常量池引用
    String a3 = "bcd"+"efg";//a3在常量池创建
    String a4 = a + a2;//a2在堆上创建新对象（所以谨记，大字符串还是尽量少拼接，使用StringBuilder）
```
* 大部分java基本类的包装类(除了浮点数float和double)都缓存了[-127-128]数字的缓存，
```java
Integer a = 30;//使用常量池中的对象
Integer b = 30;//
a==b;//true
Integer a1 = 300
Integer b1 = 300
a1==b1//false

Integer a2 = new Integer(10);
Integer b2 = new Integer(20);
Integer c2 = new Integer(30);
c2 == b2+a2;//true,+操作符不适合Integer对象，b2和c2会拆箱成，数值运算即c2==30，而Integer对象不能和值对象对比，所以c2会拆箱成30==30进行数值对比。
```