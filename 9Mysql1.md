# Mysql
## 1、innoDB和MyISAM
*   MyISAM适合读密集数据库，innoDB适合写密集表
* MyISAM不支持行锁、事物、外键、崩溃后恢复
* MyISAM的主键索引是非聚集索引，通过主键查找得到的只是数据的内存地址。而innoDB是聚集索引，数据文件本身就是索引，主键查找直接得到数据。
## 2、数据库**索引**
* 为了加快查找速度（不可能查找每个数据都遍历所有的数据），为了加快对某些列的查找速度，数据库会额外维护一种数据结构（可以说是文件），也就是索引（因此索引是某种数据结构的文件），查找这些列的时候就会先通过索引查找。
* 二分查找：要求被查找的数据有序
* 二叉树查找：要求被查找的数据是二叉树结构(注意二叉树结构和有序是有区别的)
* B-树：大部分文件系统和数据库的索引都是由B-和B+树实现的。

    * B-树
    ![image](https://upload-images.jianshu.io/upload_images/5687393-b2a7f4a75a657b0b.JPG?imageMogr2/auto-orient/)
    * 关键字（可以理解为被索引的列的值）分布在整颗B-树中（叶子节点、非叶子节点、根节点都有可能）
    * 查找可能在非叶子节点结束
    * 关键字只会在任意节点出现一次
* B+树:  
    ![](https://upload-images.jianshu.io/upload_images/5687393-717ab97b31dfa84b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/569/format/webp)
    * 非叶子节点的子树指针和关键字个数相同
    * 所有的数据存在叶子节点(非叶节点只存key(多行索引时只存主索引的字段))，并且是存了多个数据的一个有序链表。
    * 除了叶子节点本身是有序链表之外，所有的叶子节点也会组成一个链表。
    * B+树的查找不会在非叶子节点结束，必须结束于叶子节点。

* InnoDB索引的实现方式

    * 数据本身就是一个聚集索引（主索引，主键索引）
    * 辅助索引的叶子节点存放的是主键Id，因此通过辅助索引查找到主键Id之后还要再通过主键找一遍。

* 索引的使用

   * 普通索引
   * 唯一索引
   * 主键索引
   * 单列索引与多列索引（多列索引储存结构如下）
   ![](https://img-blog.csdnimg.cn/20181207153615495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NqMTIzMTk4NA==,size_16,color_FFFFFF,t_70)
   每一个节点储存的数据都是多列索引指定的那多个列的数据，按照列1、列2、列3进行排序。（即列1值相同就按照列2进行排序，一次类推）

        * 多列索引最重要的就是最左匹配原则
        * ABCD多列索引，如果B列查询不是值查询（即=），而是>、in、like等等,那么CD列将不走索引，相当于只用了一个AB索引。不走索引的意思是在 非叶节点上就不看CD的值了。只看AB的值，到达叶子数据节点时拿到结果集，然后进行全结果集扫描。
    * 1）最左前缀匹配原则：Mysql中会一直向右匹配直到遇到范围查询（>,<、between、like）就停止匹配（针对的是多列索引？）
    * 2）=和in可以乱序：a=1 and b=2 and c=3的多列索引可以是（b,c,a）,mysql的查询优化器会优化sql语句。
    * 3）使用区分度高的列作为索引：即重复数据少的列
    * 4） 索引列不能参与计算：from_unixtime(create_time) = ’2014-05-29’
    * 5）尽量扩展索引，不要新建索引:如原来已经有了a,添加（a,b）索引直接修改原来的值就行了
    * 6）外键列一定要建立索引
    * 7）查询很少的列，重复值较多的列不要建立索引
    * 8） 经常存取的列避免建立索引（值经常修改的列）
## 4、索引设计原则
* 1、在where、order by 、join的字段上建立索引，不要在重复字段上建立索引
* 2、尽量不要在设计表时留null值
* 3、在where字句中避免使用！=，<>不等于操作符，此时会放弃索引进行全表扫描
* 4、尽量避免使用or连接条件，如果一字段有索引，而另外的字段没有索引，引擎会放弃索引。可以使用union all代替or。
* 5、in和not in 慎用，否则导致全表扫描。负向查询（！= ，<>,not like,not in,!>,!<）会进行全表扫描
* 6、对于连续的值，能用between就不要用in
* 7、%key%会导致全表扫描，而key%可以使用索引
* 8、避免在where字句中对字段进行运算
* 9、mysql只会使用一个索引，因此在where中使用了索引，那么在order by中就不会使用索引

