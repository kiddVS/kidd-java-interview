# Mysql
## 1、innoDB和MyISAM
*   MyISAM适合读密集数据库，innoDB适合写密集表
* MyISAM不支持行锁、事物、外键、崩溃后恢复
* MyISAM的主键索引是非聚集索引，通过主键查找得到的只是数据的内存地址。而innoDB是聚集索引，数据文件本身就是索引，主键查找直接得到数据。
## 2、数据库**索引**
* 为了加快查找速度（不可能查找每个数据都遍历所有的数据），为了加快对某些列的查找速度，数据库会额外维护一种数据结构（可以说是文件），也就是索引（因此索引是某种数据结构的文件），查找这些列的时候就会先通过索引查找。
* 二分查找：要求被查找的数据有序
* 二叉树查找：要求被查找的数据是二叉树结构(注意二叉树结构和有序是有区别的)
* B-树：大部分文件系统和数据库的索引都是由B-和B+树实现的。

    * B-树
    ![image](https://upload-images.jianshu.io/upload_images/5687393-b2a7f4a75a657b0b.JPG?imageMogr2/auto-orient/)
    * 关键字（可以理解为被索引的列的值）分布在整颗B-树中（叶子节点、非叶子节点、根节点都有可能）
    * 查找可能在非叶子节点结束
    * 关键字只会在任意节点出现一次
* B+树:  
    ![](https://upload-images.jianshu.io/upload_images/5687393-717ab97b31dfa84b.png?imageMogr2/auto-orient/strip%7CimageView2/2/w/569/format/webp)
    * 非叶子节点的子树指针和关键字个数相同
    * 所有的数据存在叶子节点(非叶节点只存key(多行索引时只存主索引的字段))，并且是存了多个数据的一个有序链表。
    * 除了叶子节点本身是有序链表之外，所有的叶子节点也会组成一个链表。
    * B+树的查找不会在非叶子节点结束，必须结束于叶子节点。

* InnoDB索引的实现方式

    * 数据本身就是一个聚集索引（主索引，主键索引）
    * 辅助索引的叶子节点存放的是主键Id，因此通过辅助索引查找到主键Id之后还要再通过主键找一遍。

* 索引的使用

   * 普通索引
   * 唯一索引
   * 主键索引
   * 单列索引与多列索引（多列索引储存结构如下）
   ![](https://img-blog.csdnimg.cn/20181207153615495.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3NqMTIzMTk4NA==,size_16,color_FFFFFF,t_70)
   每一个节点储存的数据都是多列索引指定的那多个列的数据，按照列1、列2、列3进行排序。（即列1值相同就按照列2进行排序，一次类推）

        * 多列索引最重要的就是最左匹配原则
        * ABCD多列索引，如果B列查询不是值查询（即=），而是>、in、like等等,那么CD列将不走索引，相当于只用了一个AB索引。不走索引的意思是在 非叶节点上就不看CD的值了。只看AB的值，到达叶子数据节点时拿到结果集，然后进行全结果集扫描。
    * 1）最左前缀匹配原则：Mysql中会一直向右匹配直到遇到范围查询（>,<、between、like）就停止匹配（针对的是多列索引？）
    * 2）=和in可以乱序：a=1 and b=2 and c=3的多列索引可以是（b,c,a）,mysql的查询优化器会优化sql语句。
    * 3）使用区分度高的列作为索引：即重复数据少的列
    * 4） 索引列不能参与计算：from_unixtime(create_time) = ’2014-05-29’
    * 5）尽量扩展索引，不要新建索引:如原来已经有了a,添加（a,b）索引直接修改原来的值就行了
    * 6）外键列一定要建立索引
    * 7）查询很少的列，重复值较多的列不要建立索引
    * 8） 经常存取的列避免建立索引（值经常修改的列）
## 4、索引设计原则
* 1、在where、order by 、join的字段上建立索引，不要在重复字段上建立索引
* 2、尽量不要在设计表时留null值
* 3、在where字句中避免使用！=，<>不等于操作符，此时会放弃索引进行全表扫描
* 4、尽量避免使用or连接条件，如果一字段有索引，而另外的字段没有索引，引擎会放弃索引。可以使用union all代替or。
* 5、in和not in 慎用，否则导致全表扫描。负向查询（！= ，<>,not like,not in,!>,!<）会进行全表扫描
* 6、对于连续的值，能用between就不要用in
* 7、%key%会导致全表扫描，而key%可以使用索引
* 8、避免在where字句中对字段进行运算
* 9、mysql只会使用一个索引，因此在where中使用了索引，那么在order by中就不会使用索引
## 5、数据库的锁
* 基于锁粒度可以分为表锁和行锁，行锁相比于表锁加锁开销大，加锁慢，会出现死锁，发生冲突概率大，并发度高。
* InnoDB支持行锁和表锁，MyISAM只支持表锁。InnoDB在不走索引的时候走表锁，走索引的时候走行锁。
* 表锁分为表读锁和表写锁，读读不阻塞，读写阻塞，写写阻塞
* InnoDB实现两种类型的行锁

   * **读锁-共享锁-S锁**：给行加上读锁之后，读锁是共享的，多个客户可以同时获取资源，但是阻止其它事物获取相同数据集的排它锁。
   * **写锁-排它锁-X锁**：给行加上排他锁之后，不允许获取共享锁和排它锁。

*  各种隔离级别加锁情况：
    * RC级别：快照读（普通select）不加锁，当前读（select forupdate,update,insert,delete）给数据的 索引行和 数据行 加X锁。
    * RR级别：快照读（普通select）不加锁，当前读给数据索引行和数据行加X锁，并且在索引条件之间和数据行之间加 GAP锁，防止数据插入。
    * SI级别： 普通select加S锁，当前读和RR级别一样（比较完整的实现了ACID）
## 6、关系型数据库**事物**遵循的原则
* 原子性：事物是最小的执行单位，要么全都成功，要么全部失败
* 一致性：事物执行前后，数据要保持一致性
* 隔离性：事物之间彼此隔离，并发访问时一个事物不能被其它事物影响
* 持久性：事物提交之后对数据的影响是持久了，即使数据库发生故障也不影响。
为了达到上述事物的特性，我们可以在Mysql数据库可以定义不同的事物隔离级别：
* ReadUncommitted(读未提交)：脏读、不可重复读、幻读
* Readcommitted(读已提交)：不可重复读、幻读
* RepeatableRead（可重复读）：幻读
* Serializable（串行）：完全遵循ACID规则，事物串行执行。
不同隔离级别导致的后果：
* 脏读：事物A过程中，读到了事物B未提交的数据，事物B回滚，数据并不是A读到的那一份了。
* 不可重复读：事物只会读到其它事物已经提交的数据，在事物B提交之前，事物A读的是d0，但是等到B提交之后，事物A读到的是d1，导致不可重复读。
* 幻读： RepeatableRead为了解决不可重复读，事物A在本次事物过程中读到的版本都是一致的，不会受到B的任何影响。 但是还是会有幻读问题，幻读之和插入有关，并不是和某一行有关。事物读到了其他事物插入的数据。
**注意**：
* （1）事物的隔离级别是对每个事物来说的，并不是对全局来说，你可以为每个事物单独设置隔离级别。事物A RU，事物B RC。
* （2）一般的例子举的都是事物隔离级别一样，并且都是A读，B更新，B更新之后和B提交之后A读取的数据的变化状态。
* （3）不同隔离级别两事物同时更新
* （4）注意如果B做了一系列更新或者提交， A再进行更新，此时**A（更新、删除、插入操作）读到（这里的读不是select操作，而是update或delete操作）的是数据的最新版本有效版本（即提交了的版本）**

    * 比如B把数据 1，300 更新成1,350,但没有提交
## 7.MVCC和数据库隔离级别之间的关系
*   为了达到RC和RR级别的要求，mysql使用了MVCC（多版本并发控制）机制来存储和读取数据。

    * 存储：每次更新将旧的数据份保存下来，新的数据指向旧数据，类似于git的线性提交，数据行的版本号是事物Id。
    * 读取：读取符合要求的版本号信息。
*  快照读：由mvcc 和 事物快照实现，事物快照保存当前所有活动事物的信息，根据该状态来判断哪个版本的数据会被读取。
*  当前读：和mvcc没有关系，不根据版本控制去读取数据，读最新。
*  只有在RC和RR级别的普通select语句才会使用快照读，也就是说只有在RC和RR级别的普通的select语句才和MVCC有关系。
* 在RR级别下，快照读是通过MVVC(多版本控制)和undo log来实现的，当前读是通过加record lock(记录锁)和gap lock(间隙锁)来实现的。
